#include <stdint.h>
#include <stdbool.h>

#include "efm32gg.h"
#include "sound.h"

/*
 * Reference tables for calculating fractional exponents.
 * We use integers there because floats appear to be slower.
 */

/* Values (2^(i/63) - 1) with 12-bit precision */
const uint16_t root63Table[64] =
{
	0x000, 0x016, 0x02D, 0x044, 0x05C, 0x073, 0x08B, 0x0A3,
	0x0BC, 0x0D5, 0x0EE, 0x107, 0x121, 0x13A, 0x155, 0x16F,
	0x18A, 0x1A5, 0x1C0, 0x1DC, 0x1F8, 0x214, 0x230, 0x24D,
	0x26A, 0x288, 0x2A6, 0x2C4, 0x2E2, 0x301, 0x320, 0x340,
	0x360, 0x380, 0x3A1, 0x3C2, 0x3E3, 0x404, 0x427, 0x449,
	0x46C, 0x48F, 0x4B2, 0x4D6, 0x4FB, 0x520, 0x545, 0x56A,
	0x590, 0x5B7, 0x5DE, 0x605, 0x62D, 0x655, 0x67D, 0x6A6,
	0x6D0, 0x6FA, 0x724, 0x74F, 0x77B, 0x7A6, 0x7D3, 0x800
};

/* Values 2^(i/240) with 14-bit precision */
const uint16_t root240Table[240] =
{
	0x2000, 0x2017, 0x202F, 0x2047, 0x205F, 0x2077, 0x208F, 0x20A7,
	0x20BF, 0x20D7, 0x20F0, 0x2108, 0x2120, 0x2139, 0x2152, 0x216A,
	0x2183, 0x219C, 0x21B5, 0x21CE, 0x21E7, 0x2200, 0x2219, 0x2232,
	0x224B, 0x2265, 0x227E, 0x2298, 0x22B1, 0x22CB, 0x22E5, 0x22FF,
	0x2319, 0x2333, 0x234D, 0x2367, 0x2381, 0x239B, 0x23B6, 0x23D0,
	0x23EB, 0x2405, 0x2420, 0x243B, 0x2456, 0x2470, 0x248B, 0x24A6,
	0x24C2, 0x24DD, 0x24F8, 0x2514, 0x252F, 0x254B, 0x2566, 0x2582,
	0x259E, 0x25B9, 0x25D5, 0x25F1, 0x260D, 0x262A, 0x2646, 0x2662,
	0x267F, 0x269B, 0x26B8, 0x26D4, 0x26F1, 0x270E, 0x272B, 0x2748,
	0x2765, 0x2782, 0x279F, 0x27BD, 0x27DA, 0x27F8, 0x2815, 0x2833,
	0x2851, 0x286F, 0x288D, 0x28AB, 0x28C9, 0x28E7, 0x2905, 0x2924,
	0x2942, 0x2961, 0x297F, 0x299E, 0x29BD, 0x29DC, 0x29FB, 0x2A1A,
	0x2A39, 0x2A58, 0x2A78, 0x2A97, 0x2AB7, 0x2AD6, 0x2AF6, 0x2B16,
	0x2B36, 0x2B56, 0x2B76, 0x2B96, 0x2BB6, 0x2BD6, 0x2BF7, 0x2C17,
	0x2C38, 0x2C59, 0x2C7A, 0x2C9B, 0x2CBC, 0x2CDD, 0x2CFE, 0x2D1F,
	0x2D41, 0x2D62, 0x2D84, 0x2DA6, 0x2DC7, 0x2DE9, 0x2E0B, 0x2E2D,
	0x2E50, 0x2E72, 0x2E94, 0x2EB7, 0x2ED9, 0x2EFC, 0x2F1F, 0x2F42,
	0x2F65, 0x2F88, 0x2FAB, 0x2FCE, 0x2FF2, 0x3015, 0x3039, 0x305C,
	0x3080, 0x30A4, 0x30C8, 0x30EC, 0x3111, 0x3135, 0x3159, 0x317E,
	0x31A2, 0x31C7, 0x31EC, 0x3211, 0x3236, 0x325B, 0x3281, 0x32A6,
	0x32CB, 0x32F1, 0x3317, 0x333D, 0x3363, 0x3389, 0x33AF, 0x33D5,
	0x33FB, 0x3422, 0x3449, 0x346F, 0x3496, 0x34BD, 0x34E4, 0x350B,
	0x3533, 0x355A, 0x3581, 0x35A9, 0x35D1, 0x35F9, 0x3621, 0x3649,
	0x3671, 0x3699, 0x36C2, 0x36EA, 0x3713, 0x373C, 0x3764, 0x378D,
	0x37B7, 0x37E0, 0x3809, 0x3833, 0x385C, 0x3886, 0x38B0, 0x38DA,
	0x3904, 0x392E, 0x3959, 0x3983, 0x39AE, 0x39D8, 0x3A03, 0x3A2E,
	0x3A59, 0x3A84, 0x3AB0, 0x3ADB, 0x3B07, 0x3B32, 0x3B5E, 0x3B8A,
	0x3BB6, 0x3BE3, 0x3C0F, 0x3C3B, 0x3C68, 0x3C95, 0x3CC2, 0x3CEF,
	0x3D1C, 0x3D49, 0x3D76, 0x3DA4, 0x3DD1, 0x3DFF, 0x3E2D, 0x3E5B,
	0x3E89, 0x3EB8, 0x3EE6, 0x3F15, 0x3F43, 0x3F72, 0x3FA1, 0x3FD0
};

/***---------------------------------------------------------------***/

uint32_t seed = 0;

int8_t noiseLCG()
{
	/*
	 * Simple linear congruential generator for generating white noise.
	 * Parameters taken from glibc.
	 */
	seed = ((seed * 1103515245) + 12345) & 0x7fffffff;

	return (seed & 0x7f) * ((seed >> 7) < 0x800000 ? -1 : 1);
}

int8_t adjustVolume(int8_t sample, uint8_t volume)
{
	/*
	 * Humans perceive volume logarithmically,
	 * so we calculate it in a similar way:
	 * 2^(volume / 63) - 1
	 */
	 return (sample * root63Table[volume]) >> 11;
}

uint16_t getFrequency(uint32_t frame)
{
	/* The first eleven bits of a frame contain the pitch data */
	uint16_t pitch = frame >> 21;

	if(pitch < 64)
	{
		/* Linear value (but stay away from zero to avoid undefined behavior) */
		return pitch ? pitch : 1;
	}
	else
	{
		/* Logarithmic value: 55 * 2^(pitch / 240) Hz */
		return ((55 << (pitch / 240)) * root240Table[pitch % 240]) >> 13;
	}
}

void setupDAC()
{
	/*
	 * 1. Enable the DAC clock by setting bit 17 in CMU_HFPERCLKEN0 2.
	 * Prescale DAC clock by writing 0x50010 to DAC0_CTRL 3. Enable left
	 * and right audio channels by writing 1 to DAC0_CH0CTRL and
	 * DAC0_CH1CTRL 4. Write a continuous stream of samples to the DAC
	 * data registers, DAC0_CH0DATA and DAC0_CH1DATA, for example from a
	 * timer interrupt 
	 */
	*CMU_HFPERCLKEN0 |= (1 << 17);
	*DAC0_CTRL = 0x50010;
	*DAC0_CH0CTRL = 1;
	*DAC0_CH1CTRL = 1;
	
}
